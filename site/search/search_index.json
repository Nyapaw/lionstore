{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Lionstore is meant to be a low impact, reliable alternative to ProfileService and DataStore2. Lionstore aims to be as minimal as possible yet powerful. Having the capability of ProfileService's session locking, and using backups like DataStore2, lionstore provides a robust way to save your data. Lionstore is fault tolerant. If your data becomes corrupted, no problem; enter habitats , a way to catch errors and mark them from saving before it gets deleted. Partitions are a powerful feature of the library. The reason why it's so lightweight is that it gives you the ability to split the allocation of your data into multiple partitions. No need for ordered data stores anymore. Every time a player's data gets loaded, a partition gets discarded so there's a revision history based on how many partitions exist. The API is very minimal. Everything is already implemented for you. You don't need to store player objects in tables, it does it for you. Session locking means that if a player rejoins while the past server is saving, data won't be lost. Lionstore is low impact. Data is only retrieved once, and periodically sends a lock request every 4 minutes per session. There's no set functions, only update . Data automatically get reconciled upon load.","title":"Home"},{"location":"#home","text":"Lionstore is meant to be a low impact, reliable alternative to ProfileService and DataStore2. Lionstore aims to be as minimal as possible yet powerful. Having the capability of ProfileService's session locking, and using backups like DataStore2, lionstore provides a robust way to save your data. Lionstore is fault tolerant. If your data becomes corrupted, no problem; enter habitats , a way to catch errors and mark them from saving before it gets deleted. Partitions are a powerful feature of the library. The reason why it's so lightweight is that it gives you the ability to split the allocation of your data into multiple partitions. No need for ordered data stores anymore. Every time a player's data gets loaded, a partition gets discarded so there's a revision history based on how many partitions exist. The API is very minimal. Everything is already implemented for you. You don't need to store player objects in tables, it does it for you. Session locking means that if a player rejoins while the past server is saving, data won't be lost. Lionstore is low impact. Data is only retrieved once, and periodically sends a lock request every 4 minutes per session. There's no set functions, only update . Data automatically get reconciled upon load.","title":"Home"},{"location":"api/","text":"API InfoSettings Passed into Lionstore.SetInfo Partitions number Required Must be 1+, allocates a DataStore into smaller partitions with limit DataSize/Partitions chars; DataSize is the char limit . More partitions gives you more leeway on restoring past backups but reduces the size of your partitions. Warning Once set, you can't change this unless you use a new key Default table Required The default data loaded into a new player. If missing entries of a preloaded profile exists, the data will be reconciled . DisregardLimitCheck bool Don't call JSONDecode whenever you update the data and gets rid of the limit check. Suitable if you're changing data tons of times with large tables and you know it won't be over the partition limit. HandleLocked callback(Player: instance, Data: MainData) -> boolean Calls when the profile is locked and does not load. If true is returned, continue loading. HandleCorruption callback(Player: instance, Data: MainData) -> boolean Calls when the profile is corrupted and does not load. If true is returned, continue loading. BeforeSave modifier(Player: instance, Data: table) -> Data Calls when the profile is about to be saved. Must return profile data . Use to serialize. BeforeInitialGet modifier(Player: instance, Data: table) -> Data Calls when after a value is received from Roblox data stores. Must return profile data . Use to deserialize. Lionstore .SetInfo SetInfo(InfoSettings) Set lionstore settings. .GetProfile GetProfile(Player: instance) -> Profile? Get a profile from the player if it exists. .new new(key: string, Player: instance) -> Profile Makes a new profile. Profile :loaded loaded () -> boolean Returns whether the data is loaded. :get get() -> table Returns the data. :update update(modifier(data: table) -> data) Update the data. Must return profile data . :habitat habitat(run: callback(data: table), onCorrupt?: callback(error: string, identifiers?: ...), identifiers?: ...) Create a habitat where the run callback is passed data. Acts as a pcall. Whenever an error arises, sets profile status to corrupt and calls onCorrupt . Optional identifiers can be passed into the callback. Info This is the recommended way to run code in which you are dealing with profile data, no matter if you are getting or setting! :Lock Lock() Yields until the profile is locked. The library automatically locks the profile every 4 minutes so you can forget about this. Adds 10 minutes + os.time to the lock timer. :Save Save() -> Promise Saves the profile. Returns a promise . Sets lock timer to 0 and increments the version number. The library automatically saves the profile when the player leaves. :SaveAsync SaveAsync() :Save but yields the thread. :isLocked isLocked() -> boolean Returns whether the profile is locked. .Release BindableEvent If your profile is locked by another server as it saves, you can connect to this when the profile is released. Don't use :Wait since it may not fire at all. .MainData Warning NILABLE if profile is not loaded. Use :loaded to check! { Corrupted: boolean, Data: array VERSION: number, Locked: number } A table describing the player's data. VERSION is the number of times the player has :Save called, Data is the array where indices are 1 to Partitions where 1 is the latest data. Locked is the number signifying if the profile is locked- unix time < Locked . Corrupted signifies that the profile is corrupted.","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#infosettings","text":"Passed into Lionstore.SetInfo","title":"InfoSettings"},{"location":"api/#partitions","text":"number Required Must be 1+, allocates a DataStore into smaller partitions with limit DataSize/Partitions chars; DataSize is the char limit . More partitions gives you more leeway on restoring past backups but reduces the size of your partitions. Warning Once set, you can't change this unless you use a new key","title":"Partitions"},{"location":"api/#default","text":"table Required The default data loaded into a new player. If missing entries of a preloaded profile exists, the data will be reconciled .","title":"Default"},{"location":"api/#disregardlimitcheck","text":"bool Don't call JSONDecode whenever you update the data and gets rid of the limit check. Suitable if you're changing data tons of times with large tables and you know it won't be over the partition limit.","title":"DisregardLimitCheck"},{"location":"api/#handlelocked","text":"callback(Player: instance, Data: MainData) -> boolean Calls when the profile is locked and does not load. If true is returned, continue loading.","title":"HandleLocked"},{"location":"api/#handlecorruption","text":"callback(Player: instance, Data: MainData) -> boolean Calls when the profile is corrupted and does not load. If true is returned, continue loading.","title":"HandleCorruption"},{"location":"api/#beforesave","text":"modifier(Player: instance, Data: table) -> Data Calls when the profile is about to be saved. Must return profile data . Use to serialize.","title":"BeforeSave"},{"location":"api/#beforeinitialget","text":"modifier(Player: instance, Data: table) -> Data Calls when after a value is received from Roblox data stores. Must return profile data . Use to deserialize.","title":"BeforeInitialGet"},{"location":"api/#lionstore","text":"","title":"Lionstore"},{"location":"api/#setinfo","text":"SetInfo(InfoSettings) Set lionstore settings.","title":".SetInfo"},{"location":"api/#getprofile","text":"GetProfile(Player: instance) -> Profile? Get a profile from the player if it exists.","title":".GetProfile"},{"location":"api/#new","text":"new(key: string, Player: instance) -> Profile Makes a new profile.","title":".new"},{"location":"api/#profile","text":"","title":"Profile"},{"location":"api/#loaded","text":"loaded () -> boolean Returns whether the data is loaded.","title":":loaded"},{"location":"api/#get","text":"get() -> table Returns the data.","title":":get"},{"location":"api/#update","text":"update(modifier(data: table) -> data) Update the data. Must return profile data .","title":":update"},{"location":"api/#habitat","text":"habitat(run: callback(data: table), onCorrupt?: callback(error: string, identifiers?: ...), identifiers?: ...) Create a habitat where the run callback is passed data. Acts as a pcall. Whenever an error arises, sets profile status to corrupt and calls onCorrupt . Optional identifiers can be passed into the callback. Info This is the recommended way to run code in which you are dealing with profile data, no matter if you are getting or setting!","title":":habitat"},{"location":"api/#lock","text":"Lock() Yields until the profile is locked. The library automatically locks the profile every 4 minutes so you can forget about this. Adds 10 minutes + os.time to the lock timer.","title":":Lock"},{"location":"api/#save","text":"Save() -> Promise Saves the profile. Returns a promise . Sets lock timer to 0 and increments the version number. The library automatically saves the profile when the player leaves.","title":":Save"},{"location":"api/#saveasync","text":"SaveAsync() :Save but yields the thread.","title":":SaveAsync"},{"location":"api/#islocked","text":"isLocked() -> boolean Returns whether the profile is locked.","title":":isLocked"},{"location":"api/#release","text":"BindableEvent If your profile is locked by another server as it saves, you can connect to this when the profile is released. Don't use :Wait since it may not fire at all.","title":".Release"},{"location":"api/#maindata","text":"Warning NILABLE if profile is not loaded. Use :loaded to check! { Corrupted: boolean, Data: array VERSION: number, Locked: number } A table describing the player's data. VERSION is the number of times the player has :Save called, Data is the array where indices are 1 to Partitions where 1 is the latest data. Locked is the number signifying if the profile is locked- unix time < Locked . Corrupted signifies that the profile is corrupted.","title":".MainData"},{"location":"tips/","text":"Tips On HandleLocked you can steal a lock if you return true. A good use is wait n seconds for another server to save your data, polling the callback. If after n seconds nothing changes, return true. By default studio doesn't save data. You can change this by putting lionstoreSave in ServerStorage.","title":"Tips"},{"location":"tips/#tips","text":"On HandleLocked you can steal a lock if you return true. A good use is wait n seconds for another server to save your data, polling the callback. If after n seconds nothing changes, return true. By default studio doesn't save data. You can change this by putting lionstoreSave in ServerStorage.","title":"Tips"},{"location":"usage/","text":"Usage Lionstore automatically keeps profiles alive as long as the player has not left. Saves are brute force and will be retried until the save succeeds. local Lionstore = require ( script . Parent . Lionstore ) Lionstore . SetInfo ({ Partitions = 9 , Default = { Log = 0 }, HandleLocked = function ( Player ) print ( Player . Name .. \" has data loaded elsewhere\" ) end , HandleCorruption = function ( Player ) print ( Player . Name .. \" has bad data\" ) end , BeforeSave = function ( Player , Data ) print ( Player . Name .. \" is about to save\" ) return Data end , BeforeInitialGet = function ( Player , Data ) print ( Player . Name .. \" is getting data\" ) return Data end , }) game . Players . PlayerAdded : Connect ( function ( Player ) local Profile = Lionstore . new ( \"key28285122\" , Player ) Profile : habitat ( function ( Data ) Profile : update ( function () Data . Log += 1 return Data end ) print ( \"person logged in; \" .. Data . Log ) end ) end )","title":"Usage"},{"location":"usage/#usage","text":"Lionstore automatically keeps profiles alive as long as the player has not left. Saves are brute force and will be retried until the save succeeds. local Lionstore = require ( script . Parent . Lionstore ) Lionstore . SetInfo ({ Partitions = 9 , Default = { Log = 0 }, HandleLocked = function ( Player ) print ( Player . Name .. \" has data loaded elsewhere\" ) end , HandleCorruption = function ( Player ) print ( Player . Name .. \" has bad data\" ) end , BeforeSave = function ( Player , Data ) print ( Player . Name .. \" is about to save\" ) return Data end , BeforeInitialGet = function ( Player , Data ) print ( Player . Name .. \" is getting data\" ) return Data end , }) game . Players . PlayerAdded : Connect ( function ( Player ) local Profile = Lionstore . new ( \"key28285122\" , Player ) Profile : habitat ( function ( Data ) Profile : update ( function () Data . Log += 1 return Data end ) print ( \"person logged in; \" .. Data . Log ) end ) end )","title":"Usage"}]}